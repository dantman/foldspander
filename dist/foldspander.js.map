{"version":3,"names":[],"mappings":"","sources":["foldspander.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar _ = require('lodash');\nvar utils = require('./utils');\n\n/**\n * @class Foldspander\n * @param {Object} [options]\n * @param {Boolean} [options.native=false] - Fold and expand native JavaScript objects\n * @param {String} [options.token='@'] - Token to identify Foldspander properties\n * @param {Function} [options.descend] - Function to decide if fold and expand should descend into an object\n * @return {Foldspander} - When called without new\n */\nvar Foldspander = module.exports = function(options) {\n  options = options || {};\n\n  if(!(this instanceof Foldspander)) {\n    return new Foldspander(options);\n  }\n\n  this.options = options;\n\n  var defaultOptions = {\n    token: '$',\n    native: false,\n    descend: _.negate(utils.isRepresentableAsJSON)\n  };\n\n  _.defaults(this.options, options, defaultOptions);\n\n  _.bindAll(this, 'fold', 'expand', '_foldOne', 'add', 'has', 'remove', 'native', '_tokenize');\n\n  // bind these functions to this instance\n  this._matchers = {};\n\n  if(this.options.native) {\n    this.native(this.options.native);\n  }\n\n};\n\n/**\n * @summary Map of predefined matchers\n * @enum {String}\n * @static\n */\nFoldspander.matchers = {\n\n  /**\n   * @summary Returns closure that matches an object with instanceof\n   * @param {Function} base - Matches if object is an instance of this\n   * @return {Function}\n   */\n  instanceof: function(base) {\n    return function(obj) {\n      return obj instanceof base;\n    };\n  }\n\n};\n\n/**\n * @summary Map of predefined folders\n * @enum {Function}\n * @static\n */\nFoldspander.folders = {\n\n  /**\n   * @summary Returns closure that picks properties from an object by a list\n   * @param {...String} vars - Array of properties to pick\n   * @return {Function}\n   */\n  pick: function() {\n    var vars = _.flatten(arguments, true);\n    return function(obj) {\n      return _.pick(obj, vars);\n    };\n  },\n\n  /**\n   * @summary Returns closure that picks all enumerable properties from an object\n   * @param {String} [into] - Property to put the picked variables into\n   * @return {Function}\n   */\n  pickObject: function(into) {\n    return function(obj) {\n      var vars = _.pick(obj, _.keys(obj));\n      return into ? _.object([[into, vars]]) : vars;\n    };\n  }\n\n};\n\n/**\n * @summary Map of predefined expanders\n * @enum {Function}\n * @static\n */\nFoldspander.expanders = {\n\n  /**\n   * @summary Returns closure that instantiates an class with arguments from a list\n   * @param {Function} base - Class to instantiate\n   * @param {Array} vars - Name of vars from object to pass in order to the constructor\n   * @return {Function}\n   */\n  construct: function(base, names) {\n    return function(obj) {\n\n      var vars = _.chain(obj).pick(names).toArray().value();\n      var instance = Object.create(base.prototype);\n\n      base.apply(instance, vars);\n\n      return instance;\n\n    };\n  }\n\n};\n\n/**\n * @summary Determines if a matcher is active\n * @param {String} name - Matcher to check\n * @return {Boolean}\n * @public\n */\nFoldspander.prototype.has = function(name) {\n  return name in this._matchers;\n};\n\n/**\n * @summary Add a matcher to fold/expand a type\n * @param {String} name - Name for this type\n * @param {Function} match - Function that returns true for a matching type\n * @param {Function|Array} [fold] - Function that returns folded properties\n * @param {Function|Array} [expand] - Function that expands a folded object\n */\nFoldspander.prototype.add = function(name, match, fold, expand) {\n\n  // no extra properties stored when no fold function defined\n  if(!fold) {\n    fold = function() { return {}; };\n  }\n\n  // if fold is array, get predefined folder named \"pick\"\n  if(_.isArray(fold)) {\n    fold = Foldspander.folders.pick(fold);\n  }\n\n  this._matchers[name] = {\n    name: name,\n    match: match,\n    fold: fold,\n    expand: expand\n  };\n\n};\n\n/**\n * @summary Add a class\n * @param {Function} klass - Function with a name that will match on instance of\n * @param {Function} [fold] - Function that returns folded properties. Will pick all properties if undefined\n * @param {Function} [expand] - Function that expands a folded object. Will create an instance and copy everything into if undefined\n * @throws {TypeError} When klass has no name\n */\nFoldspander.prototype.addClass = function(klass, fold, expand) {\n\n  if(!klass.name) {\n    throw new TypeError('Class function has no name');\n  }\n\n  var name = klass.name;\n  var matcher = Foldspander.matchers.instanceof(klass);\n\n  if(!_.isFunction(fold)) {\n    fold = Foldspander.folders.pickObject('props');\n  }\n\n  if(!_.isFunction(expand)) {\n    expand = function(obj) {\n      var instance = new klass();\n      _.extend(instance, obj.props);\n      return instance;\n    };\n  }\n\n  this.add(name, matcher, fold, expand);\n\n};\n\n/**\n * @summary Remove a matcher to fold/expand a type\n * @param {String} name - Name of matcher to remove\n * @public\n */\nFoldspander.prototype.remove = function(name) {\n\n  if(!this.has(name)) {\n    return;\n  }\n\n  delete this._matchers[name];\n\n};\n\n/**\n * @summary Stringifies a object to JSON using JSON.stringify and folding first\n * @param {Object} obj\n * @return {String}\n * @public\n */\nFoldspander.prototype.stringify = function(obj) {\n  var fold = this.fold(obj);\n  return JSON.stringify(fold);\n};\n\n/**\n * @summary Parses a JSON string using JSON.parse and expands it afterwards\n * @param {String} str\n * @return {Object}\n * @public\n */\nFoldspander.prototype.parse = function(str) {\n  var obj = JSON.parse(str);\n  return this.expand(obj);\n};\n\n/**\n * @summary Get a function suitable for the JSON.stringify replacer argument\n * @return {Function}\n * @public\n */\nFoldspander.prototype.getReplacer = function() {\n  var self = this;\n\n  return function(key, value) {\n    if(utils.isRepresentableAsJSON(value)) {\n      return value;\n    } else {\n      return self.fold(value);\n    }\n  };\n\n};\n\n/**\n * @summary Get a function suitable for the JSON.parse reviver argument\n * @return {Function}\n * @public\n */\nFoldspander.prototype.getReviver = function() {\n  var self = this;\n\n  return function(key, value) {\n    if(utils.isRepresentableAsJSON(value)) {\n      return value;\n    } else if(!key) {\n      return value;\n    } else {\n      return self.expand(value);\n    }\n  };\n\n};\n\n/**\n * @summary Instance folds/expands native JavaScript types\n * @param {Boolean} [to]\n * @return {Boolean}\n * @public\n */\nFoldspander.prototype.native = function(to) {\n\n  if(arguments.length === 0) {\n    return this.options.native;\n  }\n\n  var allNativeTypes = ['Date', 'RegExp', 'NaN', 'Infinity'];\n  var toAdd = to ? allNativeTypes : [];\n  var toRemove = to ? [] : allNativeTypes;\n\n  // if given array, allow to limit to native types in the array\n  if(_.isArray(to)) {\n    toAdd = _.intersection(allNativeTypes, to);\n    toRemove = _.difference(allNativeTypes, toAdd);\n  }\n\n  var shouldAdd = _.partial(_.contains, toAdd);\n  var shouldRemove = _.partial(_.contains, toRemove);\n\n  this.options.native = to;\n\n    // Date\n    if(shouldAdd('Date')) {\n      this.add('native_date', _.isDate,\n        function(obj) { return {timestamp: obj.valueOf()}; },\n        function(obj) { return new Date(obj.timestamp); }\n      );\n    } else if(shouldRemove('Date')) {\n      this.remove('native_date');\n    }\n\n    // RegExp\n    if(shouldAdd('RegExp')) {\n      this.add('native_regexp', _.isRegExp,\n        ['source', 'global', 'multiline', 'ignoreCase'],\n        function(obj) {\n          var flags = [\n            obj.multiline ? 'm' : '',\n            obj.global ? 'g' : '',\n            obj.ignoreCase ? 'i' : ''\n          ].join('');\n          return new RegExp(obj.source, flags);\n        }\n      );\n    } else if(shouldRemove('RegExp')) {\n      this.remove('native_regexp');\n    }\n\n    // NaN\n    if(shouldAdd('NaN')) {\n      this.add('native_nan', _.isNaN, null, function(obj) {\n        return NaN;\n      });\n    } else if(shouldRemove('NaN')) {\n      this.remove('native_nan');\n    }\n\n    // Infinity\n    if(shouldAdd('Infinity')) {\n      this.add('native_infinity',\n        function(obj) { return obj === Infinity || obj === -Infinity },\n        function(obj) { return {negative: obj === -Infinity}; },\n        function(obj) { return obj.negative ? -Infinity : Infinity; }\n      );\n    } else if(shouldRemove('Infinity')) {\n      this.remove('native_infinity');\n    }\n\n  return to;\n};\n\n/**\n * @summary Folds a complex object into a simple one\n * @param {Object} obj - The object to fold\n * @return {Object}\n * @public\n */\nFoldspander.prototype.fold = function(obj) {\n\n  var matcher = _.find(this._matchers, function(matcher) {\n    return matcher.match(obj);\n  });\n\n  if(matcher) {\n    // descend into to-be folded object\n    var descent = walk(this.fold, matcher.fold(obj), this.options);\n    return this._foldOne(obj, matcher.name, descent);\n  }\n\n  if(!utils.isIterableJSON(obj)) {\n    return obj;\n  }\n\n  return walk(this.fold, obj, this.options);\n};\n\n/**\n * @summary Expands a previously folded object into a native complex one\n * @param {Object} obj - The object to expand\n * @return {Object}\n * @public\n */\nFoldspander.prototype.expand = function(obj) {\n\n  var tokenKey = this._tokenize('name');\n  var name = obj[tokenKey];\n  var hasMatch = tokenKey in obj\n                 && name in this._matchers;\n\n  // encountered a folded type\n  if(hasMatch) {\n    // descend into the to-be-expanded object\n    var descent = walk(this.expand, obj, this.options);\n    return this._matchers[name].expand(descent);\n  }\n\n  if(!utils.isIterableJSON(obj)) {\n    return obj;\n  }\n\n  return walk(this.expand, obj, this.options);\n};\n\n/**\n * @summary Make a folded version of a single complex object\n * @param {Object} obj - The object to fold\n * @param {String} name - Name of the object\n * @param {Object} [props] - Properties to include\n * @return {Object}\n * @protected\n */\nFoldspander.prototype._foldOne = function(obj, name, props) {\n  props = props || {};\n  props[this._tokenize('name')] = name;\n  return props;\n};\n\n/**\n * @summary Tokenize a name\n * @param {String} name\n * @return {String}\n * @protected\n */\nFoldspander.prototype._tokenize = function(name) {\n  return this.options.token + name;\n};\n\n/**\n * @summary Iterates over an object and creates a new one\n * @param {Function} recurse - Function to evaluate what to do with a complex object\n * @param {Object} obj - Object to look at\n * @param {Object} [options]\n * @param {Function} [options.descend] - Determines if we should recurse down into the current object\n * @return {Object}\n * @private\n */\nfunction walk(recurse, obj, options) {\n  options = options || {};\n\n  var key, value, out, outval;\n  var isArray = _.isArray(obj);\n  out = isArray ? [] : {};\n\n  for(key in obj) {\n    value = obj[key];\n\n    if(options.descend(value)) {\n      outval = recurse(value);\n    } else {\n      outval = value;\n    }\n\n    if(isArray) {\n      out.push(outval);\n    } else {\n      out[key] = outval;\n    }\n\n  }\n\n  return out;\n\n}\n\n},{\"./utils\":2,\"lodash\":undefined}],2:[function(require,module,exports){\nvar _ = require('lodash');\nvar utils = module.exports = {};\n\n/**\n * @summary Determines if an object is representable as JSON\n * @param {Object} obj\n * @return {Boolean}\n */\nutils.isRepresentableAsJSON = function(obj) {\n  return _.isNull(obj)\n      || _.isBoolean(obj)\n      || _.isFinite(obj)\n      || _.isString(obj);\n};\n\n/**\n * @summary Determines if an object is iterable as JSON\n * @param {Object} obj\n * @return {Boolean}\n */\nutils.isIterableJSON = function(obj) {\n  return _.isPlainObject(obj)\n      || _.isArray(obj);\n};\n\n},{\"lodash\":undefined}],3:[function(require,module,exports){\nmodule.exports = require('./lib');\n\n},{\"./lib\":1}]},{},[3]);\n"],"file":"foldspander.js","sourceRoot":"/source/"}